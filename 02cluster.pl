#!/usr/bin/perl
use strict;
use Bio::DB::Sam;
use Getopt::Long;
my $str;
my $cwd = `pwd`;
chomp($cwd);

#$read_group_file = "$cwd/../../insert_size.lst" unless (-e $read_group_file);
my ($Help,$in,$allbam,$fasta_ref, $read_group_file,$m8_file,$outfile);
GetOptions(
    "help!"=>\$Help,             ##Help information
    "uniqueBam=s"=>\$in,         ##Unique Bam file generated by step 1
    "Bam=s"=>\$allbam,           ##Total bam file
    "fastaref=s"=>\$fasta_ref,   ##Reference fasta files
    "info=s"=>\$read_group_file, ##Info file generated by step 1
    "m8file=s"=>\$m8_file,       ##M8 repeat file generated by step 1
    "outfile=s"=>\$outfile,      ##Outfile
);
my $USAGE = <<USAGE;
Usage: perl $0 -uniqueBam <string> -Bam <string> -fastaref <string> -info <string> -m8file <string> -outfile <string>

       -uniqueBam     Unique Bam file generated by step 1
       -Bam           Total bam file (a merged BAM file of the step 1's bamList )
       -fastaref      Reference fasta files
       -info          Info file generated by step 1
       -m8file        M8 repeat file generated by step 1
       -outfile       Outfile (a plain text)

Note: $0 requires samtools to be in the default path
About software:
Name: Specific insertions detector(Sid)
Version: V1.0
Author: ZengYongli &  Wangyeming
Email:yuqichao\@genomics.cn zengyongli\@genomics.cn wangyeming\@genomics.cn
USAGE
die $USAGE if($Help);
($in && $allbam && $fasta_ref && $read_group_file && $m8_file) or die $USAGE;
open OUT, ">$outfile" or die "Fail to open $outfile\n";
my $read_length = 100;
my $tsd_read_thre = 2;	# 2
my $tsd_single_read_thre = 5;	# 5
my $tsd_base_thre = 10;	# 5
my $tsd_single_base_thre = 5;	# 15
my $tsd_basesum_thre = 20;	# 20
my $tsd_dist_thre = 30;	# 30
my $block_read_thre = 2;	# 2
my $block_single_read_thre = 5;	# 5
my $block_dist_thre = 2000;	# 2000
my $q_thre = 10;	# 10
#my $bam_NM_thre = 5;	# 5
my $mismach_num_thre = 5;
my $point_depth_thre =  200;	# 200
my $align_length_thre = 80; # 80

my $test_blockend = 14823012;
my $test_up = 109078009;
my $test_down = 109078026;
my $test_or_not = 0;
=head
die "perl $0 unique.bam all.bam all.fasta insertsize.lst m8.repeat\n"if (@ARGV != 5);
my $in = shift;
my $allbam = shift;
my $fasta_ref = shift;
my $read_group_file = shift;
my $m8_file = shift;
chomp($in);
=cut

my %insert_size_avg;
my %insert_size_std;

read_group() if (defined $read_group_file);

my %m8_len;
my %m8_class;
read_m8($m8_file);

my %hash_ref;
warn "reading ref fasta\n";
read_ref($fasta_ref);

my $bam = Bio::DB::Sam->new(-bam=>$allbam);
my $header = $bam->header();
my ($s, $e) = (0, 0);
my $type = "*";
my $time;
my $class;
my $reads;
my $ins_size;
my %end;
my %type;
my %time;
my %class;
my %reads;
my %ins_size;
my $chr = "";
my $read_group;
#my %poly_AT;
my %false_poly;
my %lpoly;
my %rpoly;
open IN, "samtools view $in|" or die;
my @arr;
while ($str = <IN>){
    @arr = split /\s+/, $str;
    $chr = $arr[2] if ($chr eq "");
    if ($chr eq $arr[2]){
        if (defined $read_group_file){
            $read_group = $1 if ($str =~ /RG:Z:(\w+)/);
        }
        my $ntype;

        if ($arr[1] & 16){	# defind strand
            $ntype = "-";
        }else{
            $ntype = "+";
        }

        my $nclass = getclass($m8_class{$arr[0]});
        $arr[0] =~ s/\*[^\s]+$//;
        if ($arr[3] >= $s && $arr[3] <= $e && $type eq $ntype){
            $e = $arr[3] + get_match_len($arr[5]) - 1;
            $time++;
            $class .=":$nclass";
            $reads .= "\*$arr[0]";
            $ins_size = $insert_size_avg{$read_group} if (defined $read_group_file && $ins_size > $insert_size_avg{$read_group});	# !!!!!!!!!!!!!!
        }else{
            if ($s != 0){
                $end{$s} = $e;
                $type{$s} = $type;
                $time{$s} = $time;
                $ins_size{$s} = $ins_size if (defined $read_group_file);
                $class{$s} = $class;
                $reads{$s} = $reads;
            }
            $s = $arr[3];
            $e = $arr[3] + get_match_len($arr[5]) - 1;
            $type = $ntype;
            $time = 1;
            $ins_size = $insert_size_avg{$read_group} if (defined $read_group_file);
            $class = $nclass;
            $reads = $arr[0];
        }
    }else{
        &main(\@arr);
        my $ntype;
        if ($arr[1] & 16){	# defind strand
            $ntype = "-";
        }else{
            $ntype = "+";
        }

        my $nclass = getclass($m8_class{$arr[0]});
        $s = $arr[3];
        $e = $arr[3] + get_match_len($arr[5]) - 1;
        $type = $ntype;
        $time = 1;
        $ins_size = $insert_size_avg{$read_group} if (defined $read_group_file);
        $class = $nclass;
        $reads = $arr[0];
        $type = "*";
        %end = ();
        %type = ();
        %time = ();
        %class = ();
        %reads = ();
        %ins_size = ();
        $chr = $arr[2];
    }	# else
}	# while
close IN;
&main(\@arr);

####################################################################################
sub min{
    my $aa = shift;
    my $bb = shift;
    if($aa > $bb){
        return $bb;
    }else{
        return $aa;
    }
}
sub max{
    my $aa = shift;
     my $bb = shift;
     if($aa > $bb){
         return $aa;
     }else{
         return $bb;
     }
 }
sub read_group{	# get read group insert size
    open RG, "<$read_group_file" or warn "can't open $read_group_file\n";
    while ($str = <RG>){
        chomp($str);
        my @zeoly = split /\s+/, $str;
        $insert_size_avg{$zeoly[0]} = $zeoly[1];
        $insert_size_std{$zeoly[0]} = $zeoly[2];
    }
    close RG;
}

sub read_m8{
	my $in = shift;
	open IN, "<$in" or die;
	while ($str = <IN>){
		my @zz = split /\s+/, $str;
		$m8_len{$zz[0]} = $zz[7] - $zz[6] + 1;
		$m8_class{$zz[0]} = $zz[1];
	}
}

sub get_match_len{	# get match length from cigar
    my $cigar = shift;
    $cigar =~ s/^\d+S//;
    $cigar =~ s/\d+S$//;
    my $len = 0;
    while ($cigar =~ /(\d+)([A-Z])/g){
        if ($2 eq "S" || $2 eq "M"){
            $len += $1;
        }elsif ($2 eq "I"){
        }elsif ($2 eq "D"){
            $len += $1
        }else{
            die "unknown cigar: $cigar\n";
        }
    }
    $len;
}

sub getclass{	# get TE class from concatenated read name (step 1)
    my $in = shift;
    chomp($in);
    my $c;
    if ($in =~ /^Alu/){
        $c = "Alu";
    }elsif ($in =~ /^L1/){
        $c = "L1";
    }elsif ($in =~ /^SVA/){
        $c = "SVA";
    }elsif ($in =~ /^LTR/){
        $c = "LTR";
    }else{
	    die "error class: $in\n";
	}
	
	return $c;
}

sub judgeclass{
	my $in = shift;
	chomp($in);
	my @arr = split /[\:\@]/, $in;
	my %te;
	foreach my $aa (@arr){
		$te{$aa}++;
	}
	my @key = sort {$te{$b} <=> $te{$a}} keys %te;
	if ( $te{$key[0]} > (($#arr + 1) / 2) ){
		return $key[0];
	}else{
		return "none";
	}
}

sub delete_block{
	my $pos = shift;
	delete $end{$pos};
	delete $type{$pos};
	delete $time{$pos};
	delete $class{$pos};
	delete $reads{$pos};
	delete $ins_size{$pos} if (exists $ins_size{$pos});
}

sub delete_tsd{
	my ($pos, $lr) = @_;
}

sub subwarn{
	my @start = sort {$a<=>$b} keys %end;
	for (my $i = 0; $i <= $#start; $i++){
		warn "$start[$i]\t$end{$start[$i]}\t$type{$start[$i]}\t$class{$start[$i]}\n";
	}
	die;
}

sub warnbp{
    my ($l, $r, $ll, $rr) =  @_;
    my @l = @{$l};
    my @r = @{$r};
    my %ll = %{$ll};
    my %rr = %{$rr};
    foreach my $l (@l){
        warn "L: $l\t$ll{$l}\n";
    }
    warn "---------------------";
    foreach my $r (@r){
        warn "R: $r\t$rr{$r}\n";
    }
}


sub warnbp2{
	my ($l, $r, $ll, $rr, $lll, $rrr) =  @_;
	my @l = @{$l};
	my @r = @{$r};
	my %ll = %{$ll};
	my %rr = %{$rr};
    my %lname = %{$lll};
    my %rname = %{$rrr};
	foreach my $l (@l){
		warn "L: $l\t$ll{$l}\n";
        foreach my $aa(@{$lname{$l}}){
            warn "$aa\n";
        }
	}
	warn "---------------------";
	foreach my $r (@r){
		warn "R: $r\t$rr{$r}\n";
        foreach my $aa(@{$rname{$r}}){
            warn "$aa\n";
        }
	}
}

# return tail softclip len from cigar
sub posclip{
	my $in = shift;
	my $len = 0;
	while ($in =~ /(\d+)([A-Z])/g){
		if ($2 eq "S" || $2 eq "M"){
			$len += $1;
		}elsif ($2 eq "I"){
		}elsif ($2 eq "D"){
			$len += $1
		}else{
			die "unknown cigar: $in\n";
		}
	}
	$len;
}

sub getcliptype{
	my $in = shift;
	chomp($in);
	my $l = 0;
	my $r = 0;
	my @arr = split //, $in;
	foreach my $aa (@arr){
		if ($arr[$aa] eq "L"){
			$l++;
		}elsif ($arr[$aa] eq "R"){
			$r++;
		}else{
			die "wrong type: $arr[$aa]\n";
		}
	}
	my $re;
	if ($l > $r){
		$re = "L";
	}elsif ($r > $l){
		$re = "R";
	}else{
		die "equal L:$l R:$r\n";
	}
	$re;
}

sub get_point_depth{
	my ($chr, $pos) = @_;
	my @align = $bam->get_features_by_location(-seq_id=>$chr, -start=>$pos, -end=>$pos);
	return scalar(@align);
}

sub get_tsd_depth{
    my ($chr, $pos1, $pos2, $name) = @_;
    my @align = $bam->get_features_by_location(-seq_id=>$chr, -start=>$pos1, -end=>$pos2);
    my $depth = 0;

    my %temphash;
    my @arr = split /\*/, $name;
    foreach my $name (@arr){
        $temphash{$name} = 1;
    }

    foreach my $align (@align){
        next if (exists $temphash{$align->query->name}  ||$align->qual < 20);
        my $start = $align->start;
        my $end = $align->end;
        my $cigar = $align->cigar_str;
        if ($pos1 > $start && $pos1 < $end && $pos2 > $start && $pos2 < $end){
            $depth++;
        }
    }
    $depth;

}

sub get_tsd_mismatch{
    my ($chr, $pos1, $pos2, $name) = @_;
    my @align = $bam->get_features_by_location(-seq_id=>$chr, -start=>$pos1, -end=>$pos2);
    my @align2;
    my @arr = split /\*/, $name;
    my %temphash;
    foreach my $name (@arr){
        $temphash{$name} = 1;
    }
    foreach my $align (@align){
        my $readname = $align->query->name;
        next unless($align->start < $pos1 && $align->end > $pos2);
        next if (exists $temphash{$align->query->name});
        push@align2,$align;
    }
    my $tsd_mismatch = get_mismatch_num(\@align2);
    return $tsd_mismatch;
}

sub get_tsd_NM{
    my ($chr, $pos1, $pos2, $name) = @_;
    my @align = $bam->get_features_by_location(-seq_id=>$chr, -start=>$pos1, -end=>$pos2);
    my @align2;
    my @arr = split /\*/, $name;
    my %temphash;
    foreach my $name (@arr){
        $temphash{$name} = 1;
    }
    foreach my $align (@align){
        next unless($align->start <  $pos1 && $align->end > $pos2);
        next if (exists $temphash{$align->query->name});
        push@align2,$align;
    }
    my $tsd_NM = get_total_NM(\@align2);
    return $tsd_NM;
}
sub gettime{
    my $time = `date`;
    chomp($time);
    $time;
}

sub get_avgqual{
    my ($align, $s, $e) = @_;
    my @zeoly = $align->qscore;
    my $qual = 0;
    for (my $i = $s; $i <= $e; $i++){
        $qual += $zeoly[$i];
    }
    my $num = $e - $s + 1;
    $qual = $qual / $num;
    return $qual;
}

sub get_error_matchstr{
    my @arr = @_;
    my $count = 0;
    foreach my $a (@arr){
        my $num = () = $a =~ /[A-Z]/g;
        $count += $num;
    }
    $count;
}

sub check_clip_ref{	# check the clip base and correspoding reference sequence
    my ($dna, $ref_dna) = @_;
    $ref_dna =~ tr/atcgn/ATCGN/;
    my @dna = split //, $dna;
    my @ref_dna = split //, $ref_dna;
    my $isclip = 0;
    my $ispoly = 0;
    if ($#ref_dna != $#dna){
        $isclip = 0;
        $ispoly = 0;
        return ($isclip,$ispoly);
    }
    #return 0 if ($#ref_dna != $#dna);
    my $count = 0;
    my $N_num = 0;
    my $A_num = 0;
    my $T_num = 0;
    for (my $i = 0; $i <= $#dna; $i++){
        $count++ if ($dna[$i] ne $ref_dna[$i]);
        $N_num++ if($dna[$i] eq 'N');
        $A_num++ if($dna[$i] eq 'A');
        $T_num++ if($dna[$i] eq 'T');
        if($i == 5){
            $ispoly = 1 if($A_num >= 5);
            $ispoly = 1 if($T_num >= 5);
        }
        if($i == 8){
            $ispoly = 1 if($A_num >= 7);
            $ispoly = 1 if($T_num >= 7);
        }
    }
    $isclip = ($count / ($#dna + 1) > 0.5 && $N_num/($#dna + 1) < 0.3) ? 1 : 0;
    if($A_num == $#dna+1 ||$T_num == $#dna+1){
        $ispoly = 1;
        $isclip = 1;
    }
    return ($isclip,$ispoly);
=head
    if ($count / ($#dna + 1) > 0.5 && $N_num/($#dna + 1) < 0.3){
        return 1;
    }else{
        return 0;
    }
=cut
}

sub check_clip_ref_num{
    my ($dna, $ref_dna) = @_;
    $ref_dna =~ tr/atcgn/ATCGN/;
    my @dna = split //, $dna;
    my @ref_dna = split //, $ref_dna;
    return 0 if ($#ref_dna != $#dna);
    my $count = 0;
    for (my $i = 0; $i <= $#dna; $i++){
        $count++ if ($dna[$i] ne $ref_dna[$i]);
    }
    return $count;
}

sub check_clip_base{	# check the consistency of all clipped base at breakpoint
    my @arr = @_;
    my $max = 0;
    my $clipbase_consistency = 0;
    my $poly = 0;
    foreach my $tmp (@arr){
        my $a = length($tmp);
        $max = $a if ($a > $max);
    }
    my $diff1 = 0;
    my $diff2 = 0;
    my $diff1_line = 0;
    my $polyA = 0;
    my $polyT = 0;
    for (my $i = 0; $i <= $max; $i++){	# position
        my @column;
        for (my $j = 0; $j <= $#arr; $j++){	# reads
            push @column, substr($arr[$j], $i, 1) if ($i < length($arr[$j]));
        }
        if ($#column >= 0){
            my $max_base = &get_max_base(@column);
            $polyA++ if($max_base eq "A");
            $polyT++ if($max_base eq "T");
        }
        if($i == 5){
            $poly = "A" if($polyA>=5);
            $poly = "T" if($polyT>=5);
        }
        if($i == 8){
            $poly = "A" if($polyA>=7);
            $poly = "T" if($polyT>=7);
        }
        if ($#column > 0){
            my ($diff, $diff_line) = check_column(@column);
            if ($diff == 1){
                $diff1++;
                if ($diff_line >= 2){
                    $diff1_line++;
                }
            }elsif ($diff > 1){
                $diff2++;
            }
        }
    }
    my $standard = 5+($#arr-5)/3;
    if ($diff2 > 5){
        $clipbase_consistency = 0;
    }elsif ($#arr >=5 && $diff1 > $standard && $diff1_line > $standard){
        $clipbase_consistency = 0;
    }elsif($diff1 > 5 && $diff1_line > 3 && $#arr == 4){
        $clipbase_consistency = 0;
    }elsif($diff1 > 5 && $#arr <4){
        $clipbase_consistency = 0;
    }else{
        $clipbase_consistency = 1;
    }
    return ($poly, $clipbase_consistency, $diff1, $diff1_line, $diff2);
}

sub check_poly_length{
    my $seq = shift;
    my $A_T = shift;
    my $poly_count = 0;
    my $is_all_poly = 1;
    for(my $i = 0;$i<length($seq);$i++){
        my $base = substr($seq,$i,1);
        if($base eq $A_T){
            $poly_count++;
        }else{
            last;
        }
    }
    return $poly_count;
}

sub check_poly{
    my @arr = @_;
    my $polyA = 0;
    my $polyT = 0;
    for (my $i = 0; $i < 9; $i++){
        my @column;
        for (my $j = 0; $j <= $#arr; $j++){
            push @column, substr($arr[$j], $i, 1) if ($i < length($arr[$j]));
        }
        if ($#column >= 0){
            my $max_base = &get_max_base(@column);
            $polyA++ if($max_base eq "A");
            $polyT++ if($max_base eq "T");
        }
        if($i == 5){
            return "A" if($polyA>=5);
            return "T" if($polyT>=5);
        }
    }
    if($polyA>=7){
        return "A";
    }elsif($polyT>=7){
        return "T";
    }else{
        return 0;
    }
}

sub get_max_base{
    my @arr = @_;
    my %hash;
    foreach my $base (@arr){
        $hash{$base}++;
    }
    my @key = sort {$hash{$b}<=>$hash{$a}} keys %hash;
    return $key[0];
}

sub check_reference_AT{
    my $pos1 = shift;
    my $pos2 = shift;
    my $polt_AT = shift;
    my ($up,$down);
    if($pos1<$pos2){
        $up = $pos1;
        $down = $pos2;
    }else{
        $up =$pos2;
        $down = $pos1;
    }
    my $length = $down-$up+1;
    my $ref = substr($hash_ref{$chr},$up-1,$length);
    $ref = uc($ref);
    my ($aa,$tt)=0;
    while($ref=~m/(A+)/g){
        $aa=$1 if(length($aa)<length($1));
    }
    while($ref=~m/(T+)/g){
        $tt=$1 if(length($tt)<length($1));
    }
    return 1 if(length($aa)>10 || length($tt)>10);
    return 0;
}
sub TSD_reference_AT{
    my $up = shift;
    my $down = shift;
    my $length = $down-$up+1;
    my $ref = substr($hash_ref{$chr},$up-1,$length);
    $ref = uc($ref);
    return $ref;
}

sub check_column{
    my @arr = @_;

    my %hash;
    foreach my $base (@arr){
        $hash{$base}++;
    }

    my @key = sort {$hash{$b}<=>$hash{$a}} keys %hash;
    return ($#key, $hash{$key[$#key]});
}


sub max{
    my ($a, $b) = @_;
    if ($a > $b){
        return $a;
    }else{
        return $b;
    }
}

sub compare_mismatch_num{
    my $ref1 = shift;
    my $ref2 = shift;
    my $ref1_pos1 = shift;
    my $ref1_pos2 = shift;
    my $ref2_pos1 = shift;
    my $ref2_pos2 = shift;
    next if($ref1_pos2 < $ref2_pos1 || $ref1_pos1 > $ref2_pos2);
    my $ref1_new = substr($ref1,max($ref1_pos1,$ref2_pos1)-$ref1_pos1,min($ref1_pos2,$ref2_pos2)-$ref1_pos1);
    my $ref2_new = substr($ref2,max($ref1_pos1,$ref2_pos1)-$ref1_pos1,min($ref1_pos2,$ref2_pos2)-$ref1_pos1);
    my $clip_mismatch =  check_clip_ref_num($ref1_new,$ref2_new);
    #my $clip_mismatch =  check_clip_ref_num($ref1,$ref2);
    return $clip_mismatch;
}

sub check_error_clip_mismatch{
    my ($chr, $pos1, $pos2, $name) = @_;
    my @align;
    my $clip_mismatch = 0;
    my $dif_clip_read = 0;
    my %temphash;
    my @arr = split /\*/, $name;
    foreach my $name (@arr){
        $temphash{$name} = 1;
        #warn "$name\n" if($pos1 == 9665657);
    }
    if($pos2 == 0){
        @align = $bam->get_features_by_location(-seq_id=>$chr, -start=>$pos1-20, -end=>$pos1+3);
        foreach my $align (@align){
            my $temp_name = $align->query->name;
            next if (exists $temphash{$align->query->name});
            if($align->cigar_str =~ /^(\d+)S/){
                next if($align->start == $pos1);
                my $clip_len = $1;
                my $tmpseq1 = substr($align->query->dna, 0, $clip_len);
                my $tmpseq_ref1 = substr($hash_ref{$chr}, $align->start - 1 - $clip_len, $clip_len);
                my $temp_clip_mismatch = compare_mismatch_num($tmpseq1,$tmpseq_ref1,$align->start-$clip_len,$align->start,$pos1-20, $pos1);
                $dif_clip_read++  if($temp_clip_mismatch>0);
                $clip_mismatch  = $clip_mismatch + $temp_clip_mismatch;
                warn "$temp_name\t$tmpseq1\t$tmpseq_ref1\t$temp_clip_mismatch\n" if($pos1 == $test_up );
            }
        }
        return ($clip_mismatch,$dif_clip_read);
    }else{
        @align = $bam->get_features_by_location(-seq_id=>$chr, -start=>$pos2-3, -end=>$pos2+20);
        foreach my $align (@align){
            next if (exists $temphash{$align->query->name});
            if($align->cigar_str =~ /(\d+)S$/){
                next if($align->end == $pos2);
                $dif_clip_read++;
                my $clip_len = $1;
                my $tmpseq1 = substr($align->query->dna, -$clip_len, $clip_len);
                my $tmpseq_ref1 = substr($hash_ref{$chr}, $align->end, $clip_len);
                my $temp_clip_mismatch = compare_mismatch_num($tmpseq1,$tmpseq_ref1,$align->end,$align->end+$clip_len,$pos2,$pos2+20);
                $dif_clip_read++  if($temp_clip_mismatch>0);
                $clip_mismatch  = $clip_mismatch + $temp_clip_mismatch;
            }
        }
        return ($clip_mismatch,$dif_clip_read);
    }
}

sub check_updown_mapQ{
    my ($chr, $up, $down, $name) = @_;
    my $search_dist = 30;
    my $updown_mapQ_thre = 65;

    warn "pre fetch: $up\t$down\n" if ($up == $test_up || $down == $test_down);
    my @pre_up = $bam->get_features_by_location(-seq_id=>$chr, -start=>$up, -end=>$up);
    my @pre_down = $bam->get_features_by_location(-seq_id=>$chr, -start=>$down, -end=>$down);
    warn "pre\t$#pre_up\t$#pre_down\n" if ($up == $test_up || $down == $test_down);
    return 0 if ($#pre_up > 1000);
    return 0 if ($#pre_down > 1000);
    my $border = 0; # defind border
    if($#pre_up > 50){
        $border = $up - $search_dist/2;
    }else{
        $border = $up - $search_dist;
    }
    my @up_align = $bam->get_features_by_location(-seq_id=>$chr, -start=>$border, -end=>$up - 1);
    if($#pre_down > 50){
        $border = $down + $search_dist/2;
    }else{
        $border = $down + $search_dist;
    }
    my @down_align = $bam->get_features_by_location(-seq_id=>$chr, -start=>$down + 1, -end=>$border);
    #my $tmp = $up_align[-1]->start;
    for(my $i=0;$i<=$#up_align;$i++){
        if($up_align[$i]->end >= $down){
            splice(@up_align,$i,1);
            $i--;
        }
    }
    for(my $i=0;$i<=$#down_align;$i++){
        if($down_align[$i]->start <= $up){
            splice(@down_align,$i,1);
            $i--;
        }
    }
    my @up_align_read_num = $bam->get_features_by_location(-seq_id=>$chr, -start=>$up-6, -end=>$up - 1);
    my @down_align_read_num = $bam->get_features_by_location(-seq_id=>$chr, -start=>$down + 1, -end=>$down + 6);
    for(my $i=0;$i<=$#up_align_read_num;$i++){
        if($up_align_read_num[$i]->end >= $down){
            splice(@up_align_read_num,$i,1);
            $i--;
        }
    }
    for(my $i=0;$i<=$#down_align_read_num;$i++){
        if($down_align_read_num[$i]->start <= $up){
            splice(@down_align_read_num,$i,1);
        }
    }
    warn "align\t$#up_align_read_num\t$#down_align_read_num\n" if ($up == $test_up || $down == $test_down);
    return 0 if (@up_align_read_num == 0 || @down_align_read_num == 0);
    warn "up num:$#up_align\tdown num:$#down_align\n" if ($up == $test_up || $down == $test_down);
    return 0 if ($#up_align <= 3 || $#down_align <= 3);# too few mapping reads

    my $up_qual = get_avg_mapQ(\@up_align);
    my $down_qual = get_avg_mapQ(\@down_align);

    warn "updown quality: $up_qual\t$down_qual\n" if ($test_up && $down == $test_down);

    return 0 unless($up_qual + $down_qual > $updown_mapQ_thre && $up_qual > 25 && $down_qual > 25);
    my $poly1 = $lpoly{$up};
    my $poly2 = $rpoly{$down};
### test mismatch num ###
    my $up_mis_num = get_mismatch_num(\@up_align);
=head
    if($up == $test_up){
        foreach my $tt(@up_align){
            my $readname = $tt->query->name;
            warn "mismatch up reads name:$readname\n";
        }
   }
   if($down == $test_down){
       foreach my $tt(@down_align){
            my $readname = $tt->query->name;
            warn "mismatch down reads name:$readname\n";
        }
    }
=cut
    my $down_mis_num = get_mismatch_num(\@down_align);
    my $ave_up_mis_num = $up_mis_num/$#up_align;
    my $ave_down_mis_num = $down_mis_num/$#up_align;
    $ave_up_mis_num == 0 if($poly2);
    $ave_down_mis_num == 0 if($poly1);
    warn "mismatch: $ave_up_mis_num\t$ave_down_mis_num\t$poly1\t$poly2\n" if ($up == $test_up ||$down == $test_down);
    return 0 if ($ave_up_mis_num >= 3 && $ave_down_mis_num >= 3);
    return 0 if ($ave_up_mis_num >= 4 || $ave_down_mis_num >= 4);
### end mismatch num test ###
=head
### test clip but not support this point mismatch num ###
    my ($left_clip_mismatch_num,$left_clip_reads) = check_error_clip_mismatch($chr,$up,0,$name);
    my ($right_clip_mismatch_num,$right_clip_reads) = check_error_clip_mismatch($chr,0,$down,$name);
    warn "clip_mismatch_num: $left_clip_mismatch_num\t$right_clip_mismatch_num\ndif_clip_reads: $left_clip_reads\t$right_clip_reads\n" if ($up == $test_up ||$down == $test_down);
    return 0 if($left_clip_mismatch_num > 100 || $right_clip_mismatch_num > 100);
    return 0 if($left_clip_mismatch_num > 30 && $right_clip_mismatch_num > 30);
    return 0 if( ($left_clip_reads>=10 && $left_clip_mismatch_num > 50) ||($right_clip_reads>=10 && $right_clip_mismatch_num > 50) );
=cut
    return 0 if(check_indel($chr,$up,$down,$name));
    return 1;
}
sub check_indel{
    my($chr,$up,$down,$name)=@_;
    my @indel_align = $bam->get_features_by_location(-seq_id=>$chr, -start=>$up, -end=>$down);
    my %temphash;
    my @arr = split /\*/, $name;
    foreach my $name (@arr){
        $temphash{$name} = 1;
        #warn "indel name $name\n" if($up == $test_up ||$down == $test_down);
    }
    warn "check indel\t$up\t$down\n" if($up == $test_up ||$down == $test_down);
    my (%deletion,%insertion);
    my (%deletion_1,%insertion_1);
    foreach my $align (@indel_align){
        my $readname = $align->query->name;
        if($readname eq '20FUKAAXX100202:1:27:2147:173025'){
            warn "111:$readname\n" if(exists $temphash{$readname});
            warn "222::$readname\n" unless(exists $temphash{$readname});
        }
        next if (exists $temphash{$readname});
        next if ($align->end < $up || $align-> start > $down);
        my $num = 0;
        my ($tag,$indel_pos);
        my $cigar = $align->cigar_str;
        while ($cigar =~ /(\d+)D/g){
            $num = $1;
            $tag = min(get_match_len($`),get_match_len($'));
            $indel_pos = $align->start + get_match_len($`);
            push @{$deletion{$indel_pos}{$num}},[$align,$tag] if($num>1);
            #push @{$deletion{$num}},[$align,$indel_pos,$tag] if($num>1);
            $deletion_1{$indel_pos}++ if($num ==1);
        }
        warn "333:$readname\n" if($readname eq '20FUKAAXX100202:1:27:2147:173025');
        while ($cigar =~ /(\d+)I/g){
            $num = $1;
            $tag = min(get_match_len($`),get_match_len($'));
            $indel_pos = $align->start + get_match_len($`);
            push @{$insertion{$indel_pos}{$num}},[$align,$tag] if($num>1);
            #push @{$insertion{$num}},[$align,$indel_pos,$tag] if($num>1);
            $insertion_1{$indel_pos}++ if($num ==1);
        }
    }
    # remove 1-base false positive #
    my @key_del_1 = sort {$deletion_1{$b}<=>$deletion_1{$a}} keys %deletion_1;
    foreach my $del(@key_del_1){
        if($deletion_1{$del}>=10){
            warn "deletion length=1:$deletion_1{$del}\t$del\n" if($up == $test_up ||$down == $test_down);
            return 1 if(abs($del-$up)<5 || abs($del-$down)<5);
        }
    }
    my @key_ins_1 = sort {$insertion_1{$b}<=>$insertion_1{$a}} keys %insertion_1;
    foreach my $idl(@key_ins_1){
        if($insertion_1{$idl}>=10){
            warn "insertion length=1:$insertion_1{$idl}\t$idl\n" if($up == $test_up ||$down == $test_down);
            return 1 if(abs($idl-$up)<5 || abs($idl-$down)<5);
        }
    }
    # remove 1-base false positive over #
    # check deletion false positive #
    foreach my $aa (keys %deletion){
        foreach my $bb (keys %{ $deletion{$aa} }){
            delete $deletion{$aa}{$bb} if($#{$deletion{$aa}{$bb}}<1);
        }
        my @del = keys %{$deletion{$aa}};
        delete $deletion{$aa} if($#del<0);
    }
    my @arr_del = keys %deletion;
    if($#arr_del != -1){
        foreach my $aa (keys %deletion){
            foreach my $bb (keys %{ $deletion{$aa} }){
                my $distance = cal_indel_distance($up,$down,$aa,$bb);
                warn "deletion 0 :$aa\t$bb\t$#{$deletion{$aa}{$bb}}\t$distance\n" if($up == $test_up ||$down == $test_down);
                if($bb > 7 && $distance<10){
                    warn "deletion 1: $aa\t$bb\t$#{$deletion{$aa}{$bb}}\t$distance\n" if($up == $test_up ||$down == $test_down);
                    return 1;
                }elsif($bb <=7 && $distance<10){
                    my $indel_depth = $#{$deletion{$aa}{$bb}};
                    next if($indel_depth<=3 && ($lpoly{$up} ||$rpoly{$down}));
                    my $test_check = check_indel_terminal_base(\@{ $deletion{$aa}{$bb} });
                    warn "deletion 2:$aa\t$bb\t$#{$deletion{$aa}{$bb}}\t$distance\t$test_check\t" if($up == $test_up ||$down == $test_down);
                    return 1 unless($distance<=3 && $test_check);
                }
            }
        }
    }
    warn "deletion OK\n" if($up == $test_up ||$down == $test_down);
    # check deletion false positive over #
    # check insertion false positive #
    foreach my $aa (keys %insertion){
        foreach my $bb (keys %{ $insertion{$aa} }){
            delete $insertion{$aa}{$bb} if($#{$insertion{$aa}{$bb}}<1);
        }
        my @ins = keys %{$insertion{$aa}};
        delete $insertion{$aa} if($#ins<0);
    }
    my @arr_ins = keys %insertion;
    if($#arr_ins != -1){
        foreach my $aa (keys %insertion){
            foreach my $bb (keys %{ $insertion{$aa} }){
                my $distance = cal_indel_distance($up,$down,$aa,$bb);
                warn "insertion 0: $aa\t$bb\t$#{$insertion{$aa}{$bb}}\t$distance\n" if($up == $test_up ||$down == $test_down);
                if($bb > 7 && $distance<10){
                    warn "insertion 1: $aa\t$bb\t$#{$insertion{$aa}{$bb}}\t$distance\n" if($up == $test_up ||$down == $test_down);
                    return 1;
                }elsif($bb <=7 && $distance<10){
                    my $indel_depth = $#{$insertion{$aa}{$bb}};
                    next if($indel_depth<=3 && ($lpoly{$up} ||$rpoly{$down}));
                    my $test_check = check_indel_terminal_base(\@{ $insertion{$aa}{$bb} });
                    warn "insertion 2:$aa\t$bb\t$#{$insertion{$aa}{$bb}}\t$distance\t$test_check\t" if($up == $test_up ||$down == $test_down);
                    if($up == $test_up ||$down == $test_down){
                        foreach my $mm (@{$insertion{$aa}{$bb}}){
                            my $align = @{$mm}[0];
                            my $readname = $align->query->name;
                            warn "insertion reads name:$readname\n";
                        }
                    }
                    return 1 unless($distance<=3 && $test_check);
                }
            }
        }
    }
    warn "Insertion OK\n" if($up == $test_up ||$down == $test_down);
    # check insertion false positive over #
    return 0;
}

sub cal_indel_distance{
    my ($up,$down,$ind_pos,$indel_num)=@_;
    my $del_distance = 0;
    my $ss = $ind_pos;my $ee = $ind_pos+$indel_num;
    if( ($up <= $ee && $up >= $ss) || ($down <= $ee && $down >= $ss) && ($up <$ss && $down > $ee) && ($up >$ss && $down < $ee)){
        return 0;### if indel and tsd have overlap
    }else{
        if($ss <=$up){
            $del_distance = min(abs($up-$ind_pos-$indel_num),abs($up-$ind_pos));
        }elsif($ee >= $down){
            $del_distance = min(abs($down-$indel_num-$ind_pos),abs($down-$ind_pos));
        }
    }
    return $del_distance;
}

sub check_indel_terminal_base{
    my $zz = shift;
    my @zz =@{$zz};
    my $count = 0;
    my $totalcount = $#{$zz};
    my $total_tag = 0;
    foreach my $arr(@zz){
        my $tag = $$arr[1];
        $count++ if($tag <=6);
        $total_tag += $tag;
    }
    my $ave_tag = $total_tag/$totalcount;
    if($count-1 == $totalcount || $ave_tag < 5){
        return 1;
    }else{
        return 0;
    }
}


sub get_avg_mapQ{
    my $zz = shift;
    my @zz = @{$zz};
    return 0 if (@zz == 0);
    my $qual = 0;
    foreach my $align (@zz){
        $qual += $align->qual;
    }
    $qual = $qual / ($#zz + 1);
    return $qual;
}

sub get_mismatch_num{
    my $zz = shift;
    my @zz = @{$zz};
    return 0 if (@zz == 0);
    my $mis_num = 0;
    my $del = 0;
    foreach my $align (@zz){
        my $md = $align->aux_get("MD");
        $md = uc($md);
        my $num = ()= $md =~ (/[A-Z]/g);
        $mis_num = $mis_num+$num;
        my $cigar = $align->cigar_str;
        while($cigar =~ /(\d+)D/g){
            $del = $del + $1;
        }
    }
    $mis_num = $mis_num - $del;
    return $mis_num;
}

sub get_total_NM{
    my $zz = shift;
    my @zz = @{$zz};
    return 0 if (@zz == 0);
    my $re = 0;
    foreach my $align (@zz){
        $re += $align->aux_get("NM");
    }
    #$re = $re / ($#zz + 1);
    return $re;
}

sub read_ref{
    my $ref = shift;
    open IN, "<$ref" or die;
    $str = <IN>;
    my $name = (split /\s+/, $str)[0];
    $name =~ s/^>//;
    my $seq = "";
    while ($str = <IN>){
        if ($str =~ /^>/){
            $hash_ref{$name} = $seq;
            $name = (split /\s+/, $str)[0];
            $name =~ s/^>//;
            $seq = "";
        }else{
            $str =~ s/\s//g;
            $seq .= $str;
        }
    }
    close IN;
    $hash_ref{$name} = $seq;
    warn "read ref fasta done!\n";
}

sub get_terminal_mismatch{
    my $md = shift;
    my @zz;
    my $ll = 0;
    my $rr = 0;
    while ($md =~ m/(\^[A-Z]+)/){
        my $len = length($1)-1;
        my $md1 = $`;
        my $md3 = $';
        my ($num1,$num2) = 0;
        if($md1 =~ m/(\d+)$/){
            $num1 = $1;
            $md1 = $`;
        }
        if($md3 =~ m/^(\d+)/){
            $num2 = $1;
            $md3 = $';
        }
        my $md2 = $len+$num1+$num2;
        $md ="$md1"."$md2"."$md3";
    }
    while ($md =~ /(\d+|[ATCG])/g){
        push @zz, $1;
    }
    my $alpha = 0;
    my $num = 0;
    for (my $i = 0; $i <= $#zz; $i++){
        if ($zz[$i] =~ /\d+/){
            last if ($zz[$i] >= 7);
            $num += $zz[$i];
        }elsif ($zz[$i] =~ /[ATCG]/){
            $alpha++;
        }else{
            die "unknown error: terminal mismatch\n";
        }
    }
    my $cut = $alpha + $num;
    if ($alpha >= $num && $cut > 0){
        $ll = $cut;
    }

    $alpha = 0;
    $num = 0;
    for (my $i = $#zz; $i >= 0; $i--){
        if ($zz[$i] =~ /\d+/){
            last if ($zz[$i] >= 7);
            $num += $zz[$i];
        }elsif ($zz[$i] =~ /[ATCG]/){
            $alpha++;
        }else{
            die "unknown error: terminal mismatch\n";
        }
    }
    $cut = $alpha + $num;
    if ($alpha >= $num && $cut > 0){
        $rr = $cut;
    }
    return ($ll, $rr, $md);
}
sub get_autual_mismatch_pos{
    my $tmpseq=shift;
    my $tmpseq_ref=shift;
    $tmpseq = uc($tmpseq);
    $tmpseq_ref = uc($tmpseq_ref);
    my $left_or_right=shift;
    my $front_or_back = shift;
    my $x = 0;
    if( ($left_or_right eq 'l' && $front_or_back eq 'b')||($left_or_right eq 'r' && $front_or_back eq 'f')){
        $tmpseq = reverse($tmpseq);
        $tmpseq_ref = reverse($tmpseq_ref);
    }
    if($front_or_back eq 'b'){
        for(my $i=0;$i<=length($tmpseq)-1;$i++){
            my $aa=substr($tmpseq,$i,1);
            my $bb=substr($tmpseq_ref,$i,1);
            next if($aa eq $bb);
            if($aa ne $bb){
                $x=$i;
                last;
            }
        }
        return $x;
    }elsif($front_or_back eq 'f'){
        for(my $i=0;$i<=length($tmpseq)-1;$i++){
            my $aa=substr($tmpseq,$i,1);
            my $bb=substr($tmpseq_ref,$i,1);
			next if($aa ne $bb);
			if($aa eq $bb){
				$x=$i;
				last;
			}
		}
		return $x;
	}
}

sub get_max_length{
	my $string = shift;
	$string =~ s/\*\*/\*/g;
	$string =~ s/^\*//;
	$string =~ s/\*$//;
	my $max = 0;
	my @aa = split /\*/, $string;
	foreach my $aa (@aa){	# aa : read name
		$max = $m8_len{$aa} if ($m8_len{$aa} > $max);
	}
	return $max;
}


sub main{
	die "no reference sequence: $chr\n" unless (exists $hash_ref{$chr});
	my $local = localtime;
	warn "$local\nprocessing: $chr\n";
	my $arr = shift;
	my @arr = @{$arr};
    $end{$s} = $e;
    $type{$s} = $type;
    $time{$s} = $time;
    $class{$s} = $class;
    $reads{$s} = $reads;
    $ins_size{$s} = $ins_size if (defined $read_group_file);

#subwarn();
    my @start;
    @start = sort {$a<=>$b} keys %end;
    warn "step1: $#start block\n";

    my $jumpthre = 5;

    for (my $run = 0; $run < 10; $run++){
        @start = sort {$a<=>$b} keys %end;
        #warn "$run: $#start\n";
        for (my $i = 0; $i < $#start - 1; $i++){
            if ($type{$start[$i]} ne $type{$start[$i + 1]} && (($time{$start[$i + 1]} < $jumpthre) || ($time{$start[$i]} + $time{$start[$i + 2]} >= 4 * $time{$start[$i + 1]}))){	# jump rubbish
                if ($type{$start[$i]} eq $type{$start[$i + 2]} && $start[$i + 2] >= $start[$i] && $start[$i + 2] <= $end{$start[$i]}){
                    $end{$start[$i]} = $end{$start[$i + 2]};
                    $time{$start[$i]} += $time{$start[$i + 2]};
                    $class{$start[$i]} .= ":$class{$start[$i + 2]}";
                    $reads{$start[$i]} .= "\*$reads{$start[$i + 2]}";
                    $ins_size{$start[$i]} = $ins_size{$start[$i + 2]} if (defined $read_group_file && $ins_size{$start[$i]} > $ins_size{$start[$i + 1]});
                    delete_block($start[$i + 1]);
                    delete_block($start[$i + 2]);
                    $i += 2;
                }
            }elsif (defined $read_group_file){	# concatenate separate blocks
                if ($type{$start[$i]} eq $type{$start[$i + 1]} && $start[$i + 1] - $end{$start[$i]} < max($ins_size{$start[$i]}, $ins_size{$start[$i + 1]})){
                    $end{$start[$i]} = $end{$start[$i + 1]};
                    $time{$start[$i]} += $time{$start[$i + 1]};
                    $class{$start[$i]} .= ":$class{$start[$i + 1]}";
                    $reads{$start[$i]} .= "\*$reads{$start[$i + 1]}";
                    $ins_size{$start[$i]} = $ins_size{$start[$i + 1]} if (defined $read_group_file && $ins_size{$start[$i]} > $ins_size{$start[$i + 1]});
                    delete_block($start[$i + 1]);
                }
            }else{
                if ($type{$start[$i]} eq $type{$start[$i + 1]} && ($start[$i + 1] - $end{$start[$i]} < 200)){
                    $end{$start[$i]} = $end{$start[$i + 1]};
                    $time{$start[$i]} += $time{$start[$i + 1]};
                    $class{$start[$i]} .= ":$class{$start[$i + 1]}";
                    $reads{$start[$i]} .= "\*$reads{$start[$i + 1]}";
                    $ins_size{$start[$i]} = $ins_size{$start[$i + 1]} if (defined $read_group_file && $ins_size{$start[$i]} > $ins_size{$start[$i + 1]});
                    delete_block($start[$i + 1]);
                }
            }
        }
    }
    @start = sort {$a<=>$b} keys %end;
    for (my $i = 0; $i < $#start; $i++){
        delete_block($start[$i]) if ($time{$start[$i]} < $block_read_thre);
    }
    @start = sort {$a<=>$b} keys %end;
    warn "step2: $#start block\n";

#subwarn();


#open IN, "samtools view $allbam |" or die;
    for (my $i = 0; $i < $#start; $i++){
        #warn "$start[$i]\t$end{$start[$i]}\t$type{$start[$i]}\t$class{$start[$i]}\n";
        #my $c1 = judgeclass($class{$start[$i]});
        #my $c2 = judgeclass($class{$start[$i + 1]});
        my $class;
        my $dist = $end{$start[$i + 1]} - $start[$i];	# original set less than 2000
        my $innerdist = $start[$i + 1] - $end{$start[$i]};	# original set more than -50
        my $flag = 0;
        my $flagn;
        my $blockstart;
        my $blockend;
        my $stat;
        my $cc;

        my $score = 0;
        if ($type{$start[$i]} eq "+" && $type{$start[$i + 1]} eq "-" && $dist < $block_dist_thre){
            $cc = "$class{$start[$i]}\@$class{$start[$i + 1]}";
            $class = judgeclass($cc);
            $flag = 1 if ($class ne "none");
            my $count = () = $cc =~ /$class/g;
            $blockstart = $start[$i];
            $blockend = $end{$start[$i + 1]};
            $stat .= "Bd";
            #$score += 0.5 * ($time{$start[$i]} + $time{$start[$i + 1]});
            $score += $count;

			my $read = $reads{$start[$i]} . "*" . $reads{$start[$i + 1]};
			$flag = 0 if (get_max_length($read) < $align_length_thre);
            if ($blockend == $test_blockend){
                my $num = get_max_length($read);
                warn "max align length: $num\n";
            }

        }elsif ($time{$start[$i]} >= $block_single_read_thre){
            if ($type{$start[$i]} eq "+"){
                $blockstart = $start[$i];
                if ($dist > $block_dist_thre){
                    $blockend = $blockstart + $block_dist_thre / 2;
                }else{	# i+1 = + or 
                    $blockend = $start[$i + 1];
                }
                $class = judgeclass($class{$start[$i]});
                my $count = () = $class{$start[$i]} =~ /$class/g;
                $flag = 2 if ($count >= $block_single_read_thre);
                $flagn = $count;
                $stat .= "Bs";
                $score += $count;

				my $read = $reads{$start[$i]};
				$flag = 0 if (get_max_length($read) < $align_length_thre);
            }elsif ($type{$start[$i]} eq "-"){
                $blockend = $end{$start[$i]};
                if ($end{$start[$i]} - $start[$i - 1] > $block_dist_thre){
                    $blockstart = $end{$start[$i]} - $block_dist_thre / 2;
                }else{
                    if ($i == 0){
                        $blockstart = $end{$start[$i]} - $block_dist_thre / 2;
                    }else{
                        $blockstart = $end{$start[$i - 1]};
                    }
                }
                $class = judgeclass($class{$start[$i]});
                my $count = () = $class{$start[$i]} =~ /$class/g;
                $flag = 3 if ($count >= $block_single_read_thre);
                $flagn = $count;
                $stat .= "Bs";
                $score += $count;

				my $read = $reads{$start[$i]};
				$flag = 0 if (get_max_length($read) < $align_length_thre);
            }else{
                die "wrong type: $type{$start[$i]}\n";
            }
        }elsif ($time{$start[$i + 1]} >= $block_single_read_thre){
            if ($type{$start[$i + 1]} eq "+"){
            }elsif ($type{$start[$i + 1]} eq "-"){
                $blockstart = $end{$start[$i + 1]} - $block_dist_thre / 2;
                $blockend = $end{$start[$i + 1]};
                $class = judgeclass($class{$start[$i + 1]});
                my $count = () = $class{$start[$i]} =~ /$class/g;
                $flag = 5 if ($count >= $block_single_read_thre);
                $flagn = $count;
                $stat .= "Bs";
                $score += $count;

				my $read = $reads{$start[$i + 1]};
				$flag = 0 if (get_max_length($read) < $align_length_thre);
            }else{
                die "wrong type: $type{$start[$i + 1]}\n";
            }
        }

        if ($score > 20){
            if ($stat =~ /Bs/){
                $score = ($score - 20) / 10 + 20;
            }elsif ($stat =~ /Bd/){
                $score = ($score - 20) / 5 + 20;
            }
        }
        if($test_or_not && $blockend != $test_blockend){
            print "$blockend\n";
            next;
        }

        #my $timea;
        #################### detect tsd
        if ($flag && ($blockend > $blockstart)){
            warn "in flag\n" if($blockend == $test_blockend);
            my %lpos;	# num of support reads
            my %rpos;
            my %lpos2;
            my %rpos2;
            #my %postype;
            my %lposread;
            my %rposread;
            my %lclipbase;
            my %rclipbase;
            my %lmatchstr;	# exact match cigar
            my %rmatchstr;
            my %lclipseq;	# clipped seq part
            my %rclipseq;
            my %lstat;
            my %rstat;
            my $lclipread = "*";
            my $rclipread = "*";
            #my @rawbamline;	# aim to storage to solve the depth problem;
            my $depthre = 120;
            warn "blockstart:$blockstart\tblockend:$blockend\tflag:$flag\n" if($blockend == $test_blockend);
            my @allalign = $bam->get_features_by_location(-seq_id=>$chr, -start=>$blockstart, -end=>$blockend);
            warn "$#allalign\n" if($blockend == $test_blockend);
            @allalign = () if ($#allalign > 100000);
            foreach my $allalign (@allalign){
                #my @bam = split /\s+/, $str;
                my $pos = $allalign->start;
                my $start = $allalign->start;
                my $end = $allalign->end;
                next if ($allalign->qual < 13);	# 0.05 error rate
                #my $match_str = $bam->aux_get("MD");
                #my $nm = $bam->aux_get("NM");
                #push @rawbamline, ($bam[0], $bam[3], $bam[5], $match_str);	# readname pos cigar matchstring
                if ($allalign->start > $blockend){
                    last;
                }elsif ($allalign->end > $blockstart){
                    if ($allalign->cigar_str =~ /^(\d+)S/){
                        my $clip_len = $1;
                        my $tmpseq = substr($allalign->query->dna, 0, $clip_len);
                        my $tmpseq_ref = substr($hash_ref{$chr}, $allalign->start - 1 - $clip_len, $clip_len);
                        my $temseq2 = substr($allalign->query->dna,$clip_len,10);
                        my $tmpseq_ref2 = substr ($hash_ref{$chr}, $allalign->start - 1,10);
                        my $x_num2 = get_autual_mismatch_pos($temseq2,$tmpseq_ref2,"l","f");
                        if($x_num2 == 0){
                            my $x_num = get_autual_mismatch_pos($tmpseq,$tmpseq_ref,"l","b");
                            my $clip_len = $clip_len - $x_num;
                            $tmpseq = substr($allalign->query->dna, 0, $clip_len);
                            $tmpseq_ref = substr($hash_ref{$chr}, $allalign->start - 1 - $clip_len-$x_num, $clip_len);
                            $pos = $pos - $x_num;
                        }else{
                            my $clip_len = $clip_len + $x_num2;
                            $tmpseq = substr($allalign->query->dna, 0, $clip_len);
                            $tmpseq_ref = substr($hash_ref{$chr}, $allalign->start - 1 - $clip_len+$x_num2, $clip_len);
                            $pos = $pos + $x_num2;
                        }
                        my $test_name = $allalign->query->name;
                        my $avg_q = get_avgqual($allalign, 0, $clip_len - 1);
                        my $tmp = $allalign->aux_get("NM");
                        my $md = $allalign->aux_get("MD");
                        my $mis_num = () = $md =~(/[A-Z]/g);
                        my $cigar = $allalign->cigar_str;
                        my $del = 0;
                        while($cigar =~ /(\d+)D/g){
                            $del = $del + $1;
                        }
                        $mis_num = $mis_num-$del;
                        my $tmpseq_2 = reverse($tmpseq);
                        my $tmpseq_ref_2 = reverse($tmpseq_ref);
                        my ($isclip,$ispoly) = check_clip_ref($tmpseq_2, $tmpseq_ref_2);
                        warn "isclip:$isclip\tispoly:$ispoly\tseq:$tmpseq\trefseq:$tmpseq_ref\n" if($allalign->query->name eq "B80683ABXX:4:43:19358:65532#0");
                        if (($ispoly ||$mis_num < $mismach_num_thre) && $isclip){
                        #if ($mis_num < $mismach_num_thre && check_clip_ref($tmpseq, $tmpseq_ref)){
                            $lpos{$pos}++;
                            $lpos2{$pos}++;
                            $lclipbase{$pos} += $clip_len;
                            #$postype{$pos} .= "L";
                            push @{$lposread{$pos}}, $allalign->query->name;
                            push @{$lmatchstr{$pos}}, $allalign->aux_get("MD");
                            $tmpseq = reverse $tmpseq;
                            push @{$lclipseq{$pos}}, $tmpseq;
                        }
                    }
                    if ($allalign->cigar_str =~ /(\d+)S$/){
                        $pos = $allalign->end;
                        my $test_name = $allalign->query->name;
                        #warn "All2:$test_name\n";
                        my $clip_len = $1;
                        my $tmpseq = substr($allalign->query->dna, -$clip_len, $clip_len);
                        my $tmpseq_ref = substr($hash_ref{$chr}, $allalign->end, $clip_len);
                        my $tmpseq2 = substr($allalign->query->dna,-$clip_len-10,10);
                        my $tmpseq_ref2 = substr($hash_ref{$chr}, $allalign->end-10,10);
                        my $x_num2 = get_autual_mismatch_pos($tmpseq2,$tmpseq_ref2,"r","f");
                        if($x_num2 == 0){
                            my $x_num = get_autual_mismatch_pos($tmpseq,$tmpseq_ref,"r","b");
                            my $clip_len = $clip_len - $x_num;
                            $tmpseq = substr($allalign->query->dna, -$clip_len, $clip_len);
                            $tmpseq_ref = substr($hash_ref{$chr}, $allalign->end+$x_num, $clip_len);
                            $pos  = $pos + $x_num;
                        }else{
                            my $clip_len = $clip_len + $x_num2;
                            $tmpseq = substr($allalign->query->dna, -$clip_len, $clip_len);
                            $tmpseq_ref = substr($hash_ref{$chr}, $allalign->end-$x_num2, $clip_len);
                            $pos  = $pos - $x_num2;
                        }
                        my $avg_q = get_avgqual($allalign, -$clip_len, -1);
                        my $tmp = $allalign->cigar_str;
                        my $md = $allalign->aux_get("MD");
                        my $mis_num = () = $md =~(/[A-Z]/g);
                        my $cigar = $allalign->cigar_str;
                        my $del = 0;
                        while($cigar =~ /(\d+)D/g){
                            $del = $del + $1;
                        }
                        $mis_num = $mis_num-$del;
                        my ($isclip,$ispoly) = check_clip_ref($tmpseq, $tmpseq_ref);
                        if (($ispoly ||$mis_num < $mismach_num_thre ) && $isclip ){
                        #if ($mis_num < $mismach_num_thre && check_clip_ref($tmpseq, $tmpseq_ref)){
                            my $tmp = $allalign->cigar_str;
                            $tmp =~ s/(\d+)S$//;
                            #$pos = $pos + posclip($tmp) - 1;
                            #$pos = $allalign->end;
                            $rpos{$pos}++;
                            $rpos2{$pos}++;
                            $rclipbase{$pos} += $clip_len;
                            #$postype{$pos} .= "R";
                            push @{$rposread{$pos}}, $allalign->query->name;
                            push @{$rmatchstr{$pos}}, $allalign->aux_get("MD");
                            push @{$rclipseq{$pos}}, $tmpseq;
                        }
                        #}elsif ($allalign->cigar_str !~ /S/ && $allalign->aux_get("MD")){
                    }
                    if ($allalign->aux_get("MD")){
                        my $map = $allalign->aux_get("MD");
                        if ($map =~ /[ATCG]/){
                            my ($lcut, $rcut, $md) = get_terminal_mismatch($map);
                            $lcut = 0 if ($allalign->cigar_str =~ /^\d+S/);
                            $rcut = 0 if ($allalign->cigar_str =~ /\d+S$/);
                            if ($lcut > 0){
                                my $pos = $allalign->start + $lcut;
                                my $test_name = $allalign->query->name;
                                #warn "1M:$test_name\t$pos\n" if($pos == $test_up || $pos ==$test_down);
                                #warn "All3:$test_name\n";
                                $lpos{$pos}++;
                                $lpos2{$pos}++;
                                $lclipbase{$pos} += $lcut;
                                push @{$lposread{$pos}}, $allalign->query->name;
                                push @{$lmatchstr{$pos}},$md;
                                #push @{$lmatchstr{$pos}}, $allalign->aux_get("MD");
                                my $tmpseq = substr($allalign->query->dna, 0, $lcut);
                                $tmpseq = reverse $tmpseq;
                                push @{$lclipseq{$pos}}, $tmpseq;
                            }
                            if ($rcut > 0){
                                my $pos = $allalign->end - $rcut;
                                my $test_name = $allalign->query->name;
                                #warn "2M:$test_name\t$pos\n" if($pos == $test_up || $pos ==$test_down);
                                #warn "All4:$test_name\n";
                                $rpos{$pos}++;
                                $rpos2{$pos}++;
                                $rclipbase{$pos} += $rcut;
                                push @{$rposread{$pos}}, $allalign->query->name;
                                push @{$rmatchstr{$pos}},$md;
                                #push @{$rmatchstr{$pos}}, $allalign->aux_get("MD");
                                my $tmpseq = substr($allalign->query->dna, -$rcut, $rcut);
                                push @{$rclipseq{$pos}}, $tmpseq;
                            }
                        }
                    }
                }
            }	# end detect candidate breakpoint
            my @larr = keys %lpos;
            my @rarr = keys %rpos;
            warnbp2(\@larr, \@rarr, \%lpos, \%rpos, \%lposread, \%rposread) if ($blockend == $test_blockend);
            #warnbp2(\@larr, \@rarr, \%lpos, \%rpos, \%lposread, \%rposread) if ($blockend == $test_blockend);
            for (my $i = 0; $i <= $#larr; $i++){
                if ($lpos{$larr[$i]} < $tsd_read_thre || $lclipbase{$larr[$i]} < $tsd_base_thre){
                    warn "first\t$lpos{$larr[$i]}\n" if($larr[$i] == $test_up);
                    delete $lpos{$larr[$i]};
                }
            }
            for (my $i = 0; $i <= $#rarr; $i++){
                if ($rpos{$rarr[$i]} < $tsd_read_thre || $rclipbase{$rarr[$i]} < $tsd_base_thre){
                    warn "first\t$rpos{$rarr[$i]}\n" if($rarr[$i] == $test_down);
                    delete $rpos{$rarr[$i]};
                }
            }
            @larr = keys %lpos;
            @rarr = keys %rpos;
            warnbp2(\@larr, \@rarr, \%lpos, \%rpos, \%lposread, \%rposread) if ($blockend == $test_blockend);
            ########### rm ...---... point
            for (my $i = 0; $i <= $#larr; $i++){
                my $llen = $#{$lposread{$larr[$i]}} + 1;
                for (my $j = 0; $j <= $#rarr; $j++){
                    # every point
                    my $rlen = $#{$rposread{$rarr[$j]}} + 1;
                    next unless (exists $rpos{$rarr[$j]} && exists $lpos{$larr[$i]});
                    my $count = 0;
                    if (abs($rarr[$j] - $larr[$i]) < $read_length){
                        foreach my $ii (@{$lposread{$larr[$i]}}){
                            foreach my $jj (@{$rposread{$rarr[$j]}}){
                                # every read name
                                if ($ii eq $jj){
                                    $count++;
                                    last;
                                }
                            }
                        }
                        if ($count >= 2){
                            if ($count / $lpos{$larr[$i]} > 0.5){
                                delete $lpos{$larr[$i]};
                                delete $lclipbase{$larr[$i]};
                            }
                            if ($count / $rpos{$rarr[$j]} > 0.5){
                                delete $rpos{$rarr[$j]};
                                delete $rclipbase{$rarr[$j]};
                            }
                        }
                    }
                }
            }
            @larr = keys %lpos;
            @rarr = keys %rpos;
            warnbp(\@larr, \@rarr, \%lpos, \%rpos) if ($blockend == $test_blockend);
            for (my $i = 0; $i <= $#larr; $i++){
                my $poly;
                my ($diff1,$diff1_2,$diff2) = 0;
                ($poly,$lstat{$larr[$i]},$diff1,$diff1_2,$diff2) = check_clip_base(@{$lclipseq{$larr[$i]}});
                $lpoly{$larr[$i]} = $poly ? 1:0;
                warn "$test_up: $poly\t$lstat{$larr[$i]}\t$diff1\t$diff1_2\t$diff2\n" if($larr[$i] == $test_up);
                my $check_AT = 0;
                $check_AT = check_reference_AT($larr[$i]+1,$larr[$i]+16,$poly) if($poly);
                if($poly && !($check_AT)){
                    warn "poly&ref: $larr[$i]\n" if($larr[$i] == $test_up);
                    next;
                }
                if ($lstat{$larr[$i]} == 0 ){
                    warn "$larr[$i]\n" if($larr[$i] == $test_up);
                    delete $lpos{$larr[$i]};
                    delete $lclipbase{$larr[$i]} if($lpos{$larr[$i]} >=5);
                }
            }
            for (my $i = 0; $i <= $#rarr; $i++){
                my $poly;
                my ($diff1,$diff1_2,$diff2) = 0;
                ($poly,$rstat{$rarr[$i]},$diff1,$diff1_2,$diff2) = check_clip_base(@{$rclipseq{$rarr[$i]}});
                $rpoly{$rarr[$i]} = $poly ? 1:0;
                warn "$test_down: $poly\t$rstat{$rarr[$i]}\t$diff1\t$diff1_2\t$diff2\n" if($rarr[$i] == $test_down);
                my $check_AT = 0;
                $check_AT = check_reference_AT($rarr[$i]-15,$rarr[$i],$poly) if($poly);
                if($poly && !($check_AT)){
                    warn "poly&ref: $rarr[$i]\n" if($rarr[$i] == $test_down);
                    next;
                }
                if ($rstat{$rarr[$i]} == 0){
                    delete $rpos{$rarr[$i]};
                    delete $rclipbase{$rarr[$i]} if($rpos{$rarr[$i]}>=5);
                }
            }
            @larr = sort {$lpos{$b}<=>$lpos{$a}} keys %lpos;
            @rarr = sort {$rpos{$b}<=>$rpos{$a}} keys %rpos;
            #warnbp(\@larr, \@rarr, \%lpos, \%rpos) if ($blockend == $test_blockend);
            warnbp2(\@larr, \@rarr, \%lpos, \%rpos, \%lposread, \%rposread) if ($blockend == $test_blockend);
            my $a = scalar(@larr);
            my $b = scalar(@rarr);
            if (@larr > 20 || @rarr > 20){
                @larr = ();
                @rarr = ();
            }
######## double side tsd
            my $tsd = "*\t*\t*\t*\t*";	# left_pos right_pos left_supp_num right_supp_num tsd_len
            my $raw_depth_left = 0;
            my $raw_depth_right = 0;
            my $het_depth = 0;
            my $tsd_mis = 0;
            my $false_poly = 0;
            my @tsd_align;
            my $clipstat;
            #my $direct_over = 0;
            for (my $i = 0; $i <= $#larr; $i++){
                #my $type1 = getcliptype($postype{$arr[$i]});
                for (my $j = 0; $j <= $#rarr; $j++){
                    #last if ($pos{$arr[$i + 1]} <= 3);
                    #my $type2 = getcliptype($postype{$arr[$j]});
                    warn "ready1: $larr[$i] $rarr[$j]\n" if ($blockend == $test_blockend);
                    my $aa1 = abs($rarr[$j] - $larr[$i] + 1);
                    my $aa2 = $lclipbase{$larr[$i]} / $lpos{$larr[$i]};
                    my $aa3 = $rclipbase{$rarr[$j]}/ $rpos{$rarr[$j]};
=head
                    my $poly1 = $lpoly{$larr[$i]};
                    my $poly2 = $rpoly{$rarr[$j]};
                    if($poly1 ne '0' && $poly2 ne '0' && $poly1 eq $poly2){
                        my $check_AT = check_reference_AT($larr[$i],$rarr[$j],$poly1);
                        if($check_AT){
                            $false_poly = 1;
                        }
                    }
=cut
                    # warn "$poly1\t$poly2\n" if($larr[$i] == $test_up && $rarr[$j] == $test_down);
                    warn "$lclipbase{$larr[$i]}\t$rclipbase{$rarr[$j]}\t$aa1\t$aa2\t$aa3\n" if($larr[$i] == $test_up && $rarr[$j] == $test_down);
                    if ($lclipbase{$larr[$i]} >= $tsd_base_thre && $rclipbase{$rarr[$j]} >= $tsd_base_thre && $lclipbase{$larr[$i]} + $rclipbase{$rarr[$j]} >= $tsd_basesum_thre && (abs($rarr[$j] - $larr[$i] + 1) <= $tsd_dist_thre) && ($lclipbase{$larr[$i]} / $lpos{$larr[$i]} > 5 || $lpoly{$larr[$i]}) &&  ($rclipbase{$rarr[$j]}/ $rpos{$rarr[$j]} > 5 || $rpoly{$rarr[$j]}) ){
                        my ($up, $down);
                        if ($larr[$i] < $rarr[$j]){
                            $up = $larr[$i];
                            $down = $rarr[$j];
                        }else{
                            $up = $rarr[$j];
                            $down = $larr[$i];
                        }
                        warn "ready2: $up $down\n" if ($blockend == $test_blockend);

                        $lclipread = join("*", @{$lposread{$larr[$i]}});
                        $rclipread = join("*", @{$rposread{$rarr[$j]}});
                        my $tempread = $lclipread . "*" . $rclipread;
                        if (check_updown_mapQ($chr, $up, $down, $tempread)){
                            warn "$i\t$j\tafter\n" if ($blockend == $test_blockend);
                            $raw_depth_left = get_point_depth($chr, $larr[$i]);
                            $raw_depth_right = get_point_depth($chr, $rarr[$j]);
                            #die "$depth1\t$depth2\n";
                            #if ($raw_depth_left < $depthre && $raw_depth_right < $depthre){
                            #if ($larr[$i] < $rarr[$j] && check_updown_mapQ($chr, $larr[$i], $rarr[$j])){
                            if ($larr[$i] < $rarr[$j]){
                                $tsd = "$larr[$i]\t$rarr[$j]\t$lpos{$larr[$i]}\t$rpos{$rarr[$j]}";
                                $lclipread = join("*", @{$lposread{$larr[$i]}});
                                $rclipread = join("*", @{$rposread{$rarr[$j]}});
                                my $tempread = $lclipread . "*" . $rclipread;
                                $het_depth = get_tsd_depth($chr, $larr[$i], $rarr[$j], $tempread);
                                #$tsd_NM = get_tsd_NM($chr,$larr[$i],$rarr[$j],$tempread);
                                $tsd_mis = get_tsd_mismatch($chr,$larr[$i],$rarr[$j],$tempread);
                                #}elsif (check_updown_mapQ($chr, $rarr[$j], $larr[$i])){
                            }else{
                                $tsd = "$rarr[$j]\t$larr[$i]\t$rpos{$rarr[$j]}\t$lpos{$larr[$i]}";
                                $lclipread = join("*", @{$rposread{$rarr[$j]}});
                                $rclipread = join("*", @{$lposread{$larr[$i]}});
                                my $tempread = $lclipread . "*" . $rclipread;
                                $het_depth = get_tsd_depth($chr, $rarr[$j], $larr[$i], $tempread);
                                #$tsd_NM = get_tsd_NM($chr,$rarr[$j],$larr[$i],$tempread);
                                $tsd_mis = get_tsd_mismatch($chr,$rarr[$j],$larr[$i],$tempread);
                            }
                            my $dist = $rarr[$j] - $larr[$i] + 1;
                            $tsd .= "\t$dist";
                            $stat .= "Td";
                            my $tscore = 0;
                            $tscore += ($lpos{$larr[$i]} + $rpos{$rarr[$j]}) + ($lclipbase{$larr[$i]} + $rclipbase{$rarr[$j]}) * 0.1 / ($lpos{$larr[$i]} + $rpos{$rarr[$j]});	# support num & base
                            $tscore += ($depthre - $raw_depth_left)/10 if ($raw_depth_left > $depthre);
                            $tscore += ($depthre - $raw_depth_right)/10 if ($raw_depth_right > $depthre);
                            $tscore *=  1.2 if ($dist >= 0 && $dist <= $tsd_dist_thre && $tscore > 0);	# distance bonus
                            $tscore *=  2 if ($het_depth < 10 && $tscore > 0 && $lpos{$larr[$i]} + $rpos{$rarr[$j]} >= 8);	# het bonus
                            $score += $tscore;
                            $i = $#larr;
                            #$clipstat = $lstat{$larr[$i]} . $rstat{$rarr[$j]};
                            last;
                            #}
                        }else{
                            warn "check fail\n" if ($blockend == 8446984);
                        }
                    }
                }
            }
#warn "double over\n";
#$time = gettime();
            unless ($stat =~ /Td/){
                $raw_depth_left = 0;
                $raw_depth_right = 0;
            }
#warn "ready single\n" if ($blockend == 121484181);
#print "double tsd done: $time\n"
            #next if($direct_over);
            if ($tsd eq "*\t*\t*\t*\t*"){	# detect single side tsd
                warn "check single\n" if ($blockend == $test_blockend);
                my $lpos = 0;
                my $rpos = 0;
                for (my $i = 0; $i <= $#larr; $i++){
                    if ($lpos{$larr[$i]} >= $tsd_single_read_thre && $lclipbase{$larr[$i]} >= $tsd_single_base_thre && $lclipbase{$larr[$i]} / $lpos{$larr[$i]} > 5){
                        $lpos = $larr[$i] if ($lpos == 0 || ($lpos{$larr[$i]} > $lpos{$lpos}) );
                    }
                }
                for (my $i = 0; $i <= $#rarr; $i++){
                    if ($rpos{$rarr[$i]} >= $tsd_single_read_thre && $rclipbase{$rarr[$i]} >= $tsd_single_base_thre && $rclipbase{$rarr[$i]} / $rpos{$rarr[$i]} > 5){
                        $rpos = $rarr[$i] if ($rpos == 0 || ($rpos{$rarr[$i]} > $rpos{$rpos}) );
                    }
                }
                my $re = "*";	# pos
                my $re_supp = "*";	# support number
                my $lrflag = 0;	# 1 for left clip; 2 for right clip
                if ($lpos{$lpos} != 0 && $rpos{$rpos} != 0 && $lpos{$lpos} / $rpos{$rpos} <= 3 && $lpos{$lpos} / $rpos{$rpos} >= 0.33){	# 
                    my $lcount = get_error_matchstr(@{$lmatchstr{$lpos}});
                    my $rcount = get_error_matchstr(@{$rmatchstr{$rpos}});
                    $lcount = 1 if ($lcount == 0);
                    $rcount = 1 if ($rcount == 0);
                    warn "$lcount\t$rcount\n" if ($blockend == $test_blockend);
                    if ($lcount / $rcount > 2){
                        $lrflag = 2;
                    }elsif ($rcount / $lcount > 2){
                        $lrflag = 1;
                    }
                }
                warn "lrflag: $lrflag\n" if($blockend == $test_blockend);
                if ($lrflag == 0){
                    warn "lrflag 000\n" if($blockend == $test_blockend);
                    if ($lpos{$lpos} > $rpos{$rpos} && $lpos != 0){
                        $lrflag = 1;
                        #unless ($flagn < 10){	# $stat eq "Bs" && $rpos{$rpos} < 10
                        #}
                    }elsif ($lpos{$lpos} < $rpos{$rpos} && $rpos != 0){
                        $lrflag = 2;
                        #unless ($flagn < 10){
                        #}
                    }elsif ($lpos == $rpos && $rpos != 0){
                        if ($lclipbase{$lpos} > $rclipbase{$rpos}){
                            $lrflag = 1;
                        }else{
                            $lrflag = 2;
                        }
                    }elsif ($lpos == 0 && $rpos == 0){
                        $re = "*";
                        $re_supp = "*";
                    }
                }
                my $tscore = 0;
                if ($lrflag == 1){
                    warn "lrflag 111\n" if($blockend == $test_blockend);
                    $re = $lpos;
                    $re_supp = $lpos{$lpos};

                    my $flag_refind = 0;	# also return position
                    my @zz = sort keys %rclipbase;
                    for (my $i = 0; $i <= $#zz; $i++){	# search for low support on 1 side
                        #next if ($rpos{$zz[$i]} >= $tsd_read_thre);	# only keep low support point
                        warn "$zz[$i]\t$rclipbase{$zz[$i]}\t$rpos2{$zz[$i]}\n" if($blockend ==  $test_blockend);
                        if ( ($zz[$i] - $re < $tsd_dist_thre && $zz[$i] - $re >= 0) && ($rclipbase{$zz[$i]} >= 5 || $rpos2{$zz[$i]} >= 2)){
                            $flag_refind = $zz[$i];
                            last;
                        }
                    }
                    @zz = sort keys %rpos;
                    if (!$flag_refind){	# search for a little long distance
                        for (my $i = 0; $i <= $#zz; $i++){
                            if ($zz[$i] - $re < $tsd_dist_thre + 10 && $zz[$i] - $re > $tsd_dist_thre){
                                $flag_refind = $zz[$i];
                                last;
                            }
                        }
                    }

                    $lclipread = join("*", @{$lposread{$lpos}});
                    $rclipread = join("*", @{$rposread{$flag_refind}}) if ($flag_refind);
                    my $tempread = $lclipread . "*" . $rclipread;
                    warn "ready check\t$flag_refind\n" if($blockend == $test_blockend);
                    if ($flag_refind && check_updown_mapQ($chr, $lpos, $flag_refind, $tempread)){
                        #if ($flag_refind){
                        $stat .= "Td";
                        $rclipread = join("*", @{$rposread{$flag_refind}});
                        $raw_depth_left = get_point_depth($chr, $lpos);
                        $raw_depth_right = get_point_depth($chr, $flag_refind);
                        my $tempread = $lclipread . "*" . $rclipread;
                        $het_depth = get_tsd_depth($chr, $lpos, $flag_refind, $tempread);
                        $tsd_mis = get_tsd_mismatch($chr,$lpos,$flag_refind,$tempread);
                        #$tsd_NM = get_tsd_NM($chr,$lpos,$flag_refind,$tempread);
                        $tscore += $lpos{$lpos} + 0.1 * $lclipbase{$lpos} / $lpos{$lpos};
                        $tscore += ($depthre - $raw_depth_left) / 10 if ($raw_depth_left > $depthre);
                        $tscore *= 2 if ($het_depth < 10 && $re_supp >= 5);
                        my $dist = $flag_refind - $re + 1;
                        $tscore *= 1.2;
                        $tsd = "$re\t$flag_refind\t$re_supp\t*\t$dist";
                    }elsif (check_updown_mapQ($chr, $lpos, $lpos + 25)){
                        #}else{
                        $stat .= "Ts";
                        $raw_depth_left = get_point_depth($chr, $lpos);
                        $het_depth = get_tsd_depth($chr, $lpos, $lpos + 25, $lclipread);
                        $tscore += $lpos{$lpos} + 0.1 * $lclipbase{$lpos} / $lpos{$lpos};	# support num & base
                        $tscore += ($depthre - $raw_depth_left) / 10 if ($raw_depth_left > $depthre);
                        $tscore *= 2 if ($het_depth < 10 && $re_supp >= 5);
                        #$clipstat = $lstat{$re} . "*";
                        $tsd = "$re\t$re\t$re_supp\t*\t*" if ($raw_depth_left / $lpos{$lpos} < 8);
                        #$tsd_NM = get_tsd_NM($chr,$lpos,$lpos + 25,$lclipread);
                        $tsd_mis = get_tsd_mismatch($chr,$lpos,$lpos + 25,$lclipread);
                    }
                }elsif ($lrflag == 2){
                    warn "lrflag 222\n" if($blockend == $test_blockend);
                    $re = $rpos;
                    $re_supp = $rpos{$rpos};

                    my $flag_refind = 0;	# also return position
                    my @zz = sort keys %lclipbase;
                    for (my $i = 0; $i <= $#zz; $i++){	# search for low support on 1 side
                        #next if (exists $lpos{$zz[$i]} && $lpos{$zz[$i]} >= $tsd_read_thre && $lclipbase{$zz[$i]} >= $tsd_single_base_thre);	# only keep low support point
                        warn "$zz[$i]\t$lclipbase{$zz[$i]}\t$lpos2{$zz[$i]}\n" if($blockend == $test_blockend);
                        if ( ($re - $zz[$i] < $tsd_dist_thre && $re - $zz[$i] >= 0 )&& ($lclipbase{$zz[$i]} >= 5 || $lpos2{$zz[$i]} >= 2)){
                            $flag_refind = $zz[$i];
                            last;
                        }
                    }
                    @zz = sort keys %lpos;
                    if (!$flag_refind){	# search for a little long distance
                        for (my $i = 0; $i <= $#zz; $i++){
                            if ($re - $zz[$i] < $tsd_dist_thre + 10 && $re - $zz[$i] > $tsd_dist_thre){
                                $flag_refind = $zz[$i];
                                last;
                            }
                        }
                    }

#					if ($re == 22417541){
#						die "$flag_refind\n";
#					}
                    warn "lrflag over\n" if($blockend == $test_blockend);
                    $rclipread = join("*", @{$rposread{$rpos}});
                    $lclipread = join("*", @{$lposread{$flag_refind}}) if ($flag_refind);
                    my $tempread = $lclipread . "*" . $rclipread;
                    if ($flag_refind && check_updown_mapQ($chr, $flag_refind, $rpos, $tempread)){
                        #if ($flag_refind){
                        $stat .= "Td";
                        $lclipread = join("*", @{$lposread{$flag_refind}});
                        $raw_depth_left = get_point_depth($chr, $flag_refind);
                        $raw_depth_right = get_point_depth($chr, $rpos);
                        my $tempread = $lclipread . "*" . $rclipread;
                        $het_depth = get_tsd_depth($chr, $flag_refind, $rpos, $tempread);
                        #$tsd_NM = get_tsd_NM($chr,$flag_refind,$rpos,$tempread);
                        $tsd_mis = get_tsd_mismatch($chr,$flag_refind,$rpos,$tempread);
                        $tscore += $rpos{$rpos} + 0.1 * $rclipbase{$rpos} / $rpos{$rpos};
                        $tscore += ($depthre - $raw_depth_right) / 10 if ($raw_depth_right > $depthre);
                        my $dist = $re - $flag_refind + 1;
                        $tscore *= 1.2;
                        $tscore *= 2 if ($het_depth < 10 && $re_supp >= 5);
                        $tsd = "$flag_refind\t$re\t*\t$re_supp\t$dist";
                    }elsif (check_updown_mapQ($chr, $rpos - 25, $rpos)){
                        #}else{
                        $stat .= "Ts";
                        $raw_depth_right = get_point_depth($chr, $rpos);
                        $het_depth = get_tsd_depth($chr, $rpos - 25, $rpos, $rclipread);
                        $tscore += $rpos{$rpos} + 0.1 * $rclipbase{$rpos} / $rpos{$rpos};
                        $tscore += ($depthre - $raw_depth_right) / 10 if ($raw_depth_right > $depthre);
                        $tscore *= 2 if ($het_depth < 10 && $re_supp >= 5);
                        #$clipstat = "*". $rstat{$re};
                        $tsd = "$re\t$re\t*\t$re_supp\t*" if ($raw_depth_right / $rpos{$rpos} < 8);
                        $het_depth = get_tsd_depth($chr, $rpos - 25, $rpos, $rclipread);
                        $tscore += $rpos{$rpos} + 0.1 * $rclipbase{$rpos} / $rpos{$rpos};
                        $tscore += ($depthre - $raw_depth_right) / 10 if ($raw_depth_right > $depthre);
                        $tscore *= 2 if ($het_depth < 10 && $re_supp >= 5);
                        #$clipstat = "*". $rstat{$re};
                        $tsd = "$re\t$re\t*\t$re_supp\t*" if ($raw_depth_right / $rpos{$rpos} < 8);
                        #$tsd_NM = get_tsd_NM($chr,$rpos - 25,$rpos,$rclipread);
                        $tsd_mis = get_tsd_mismatch($chr,$rpos - 25,$rpos,$rclipread);
                    }
                }
                warn "333\n" if($blockend == $test_blockend);
                $tscore *= 1.5 if ($stat =~ /Bd/);
                $score += $tscore;
                if ($re ne "*"){
                    my $depth = get_point_depth($chr, $re);
                    if ($depth > $depthre){
                        $score += ($depthre - $depth);
                    }
                }
            }   #warn "single over\n";

            if ($tsd eq "*\t*\t*\t*\t*"){
                $stat = "NULL";
                # next;
            }
#################### detect tsd end
            my @temp = split /\t/,$tsd;
            my $poly=0;
            my $temp_tsd = $temp[4];
            my $ll = $temp[0];
            my $rr = $temp[1];
            my $tsd_fererence = 0;
            if($ll ne '*'){
                my $up_tsd = $ll;
                my $down_tsd = $rr;
                if($temp_tsd<0){
                    $ll = $temp[1];
                    $rr = $temp[0];
                }
                if(exists $lpoly{$temp[0]} && $lpoly{$temp[0]} ne "0"){
                    $poly += 1;
                }
                if(exists $rpoly{$temp[1]} && $rpoly{$temp[1]} ne "0"){
                    $poly += 2;
                }
                if($temp[2] eq '*'){
                    $up_tsd = $down_tsd-25;
                }elsif($temp[3] eq '*'){
                    $down_tsd = $up_tsd+25;
                }
                $tsd_fererence = TSD_reference_AT($up_tsd,$down_tsd);
            }
            print OUT "$chr\t$tsd\t$tsd_mis\t$poly\t$tsd_fererence\tL:$raw_depth_left\tR:$raw_depth_right\tHET:$het_depth\t$score\t$stat\t$start[$i]\t$end{$start[$i + 1]}\t$time{$start[$i]}\t$time{$start[$i + 1]}\t$class\t$cc\t$flag\t$reads{$start[$i]}\t$reads{$start[$i + 1]}\t$lclipread\t$rclipread\n" if ($flag == 1);
            print OUT "$chr\t$tsd\t$tsd_mis\t$poly\t$tsd_fererence\tL:$raw_depth_left\tR:$raw_depth_right\tHET:$het_depth\t$score\t$stat\t$blockstart\t$blockend\t$time{$start[$i]}\t*\t$class\t$class{$start[$i]}\t$flag\t$reads{$start[$i]}\t*\t$lclipread\t$rclipread\n" if ($flag == 2 && $tsd ne "*\t*\t*\t*\t*");
            print OUT "$chr\t$tsd\t$tsd_mis\t$poly\t$tsd_fererence\tL:$raw_depth_left\tR:$raw_depth_right\tHET:$het_depth\t$score\t$stat\t$blockstart\t$blockend\t*\t$time{$start[$i]}\t$class\t$class{$start[$i]}\t$flag\t*\t$reads{$start[$i]}\t$lclipread\t$rclipread\n" if ($flag == 3 && $tsd ne "*\t*\t*\t*\t*");
            print OUT "$chr\t$tsd\t$tsd_mis\t$poly\t$tsd_fererence\tL:$raw_depth_left\tR:$raw_depth_right\tHET:$het_depth\t$score\t$stat\t$blockstart\t$blockend\t*\t$time{$start[$i + 1]}\t$class\t$class{$start[$i + 1]}\t$flag\t*\t$reads{$start[$i + 1]}\t$lclipread\t$rclipread\n" if ($flag == 5 && $tsd ne "*\t*\t*\t*\t*");
            $i++ if ($flag == 1);
        }	# end flag
    }	# normal
}
close OUT;
